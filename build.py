import os
import subprocess
import venv
import sys
import time

VENV_DIR = ".venv"


# This is a local project,
# so the security concerns of a production
# project are not relevant here.
ENV_DEFAULTS = {
    "POSTGRES_USER": "thomas",
    "POSTGRES_PASSWORD": "mind_the_gap",
    "POSTGRES_DB": "subway_system",
    "DBT_SOURCE_SCHEMA": "public_transit",
}


def create_env_file():
    if not os.path.exists(".env"):
        with open(".env", "w") as f:
            f.write("# Auto-generated by build.py for local docker setup\n")
            for key, value in ENV_DEFAULTS.items():
                f.write(f"{key}={value}\n")
        print(".env file created.")
    else:
        print(".env file already exists.")


def create_venv():
    if not os.path.exists(VENV_DIR):
        print(f"Creating virtual environment at {VENV_DIR}...")
        venv.create(VENV_DIR, with_pip=True)
        print("Done.")


def get_clean_exception_message(generic_exception: Exception) -> str:
    return (
        generic_exception.stderr.strip()
        if generic_exception.stderr
        else "No error message captured"
    )


def run_command(command, description, continue_if_failed=False):
    try:
        subprocess.check_call(command, shell=True)
        print(f" {description} Complete!\n")
    except subprocess.CalledProcessError as e:
        message = get_clean_exception_message(e)
        if continue_if_failed:
            print(f"Command {description} failed with: {message}")
            print("Non critical, or expected error, continuing")
        else:
            print(f"Error during: {description}:\n {message}")
            sys.exit(1)


def is_running_outside_virtual_environment() -> bool:
    return sys.prefix == sys.base_prefix


def check_env():
    # Enables one shot build, despite not having the venv up yet.
    # Catches first run edge case.
    if is_running_outside_virtual_environment():
        print("Script is running outside venv.")
        create_venv()
        if sys.platform == "win32":
            venv_python = os.path.join(VENV_DIR, "Scripts", "python.exe")
        else:
            venv_python = os.path.join(VENV_DIR, "bin", "python")
        try:
            subprocess.check_call([venv_python] + sys.argv)
        except subprocess.CalledProcessError as e:
            sys.exit(e.returncode)
        sys.exit(0)


def run_dbt_command(command, desc):
    print(f"Running {desc}...")
    original_dir = os.getcwd()

    dbt_dir = "dbt"
    if os.path.exists("dbt_project.yml"):
        dbt_dir = "."
    try:
        os.chdir(dbt_dir)
        subprocess.check_call(command, shell=True)
        print(f"{desc} Complete!\n")

    except subprocess.CalledProcessError as e:
        exception_message = get_clean_exception_message(e)
        print(f"Error during command {desc}, failed with {exception_message}")
        sys.exit(1)
    finally:
        os.chdir(original_dir)


# during development, I found that some consumers can be zombified when pressing CTRL + C
# This lead to duplication in the Kafka landing tables,
# and about 45 min of wasted time.
# I'm probably going to leave this in, since this is a "nuke everything" script.
# However, just to note, the run script does gracefully tell the processes to quit,
# So this is a fallback, guarantee if all else fails, despite that being a remote possibilty
def eradicate_zombies():
    try:
        # The -f flag tells pkill to match the full command line (e.g., 'python consumer.py')
        subprocess.run(["pkill", "-f", "consumer.py"], stderr=subprocess.DEVNULL)
        subprocess.run(["pkill", "-f", "run.py"], stderr=subprocess.DEVNULL)
        print("Process table sanitized.")
    except Exception as e:
        print(f"Zombie sweep failed (usually fine on Windows/Mac): {e}")


def main():
    print("Starting build...\n")
    create_env_file()
    check_env()
    eradicate_zombies()
    run_command(
        f"{sys.executable} -m pip install -r requirements.txt",
        "Installing Python dependencies",
    )
    run_command(
        f"{sys.executable} -m pytest src/",
        "Running data generator tests"
    )
    run_command(
        "docker compose down -v",
        "Shutting off containers, if present...",
        continue_if_failed=True,
    )
    run_command(
        "docker compose up -d --force-recreate", "Starting Docker Infrastructure"
    )
    print("Waiting 3s before attempting database initialization...")
    for i in range(3, 0, -1):
        print(i)
        time.sleep(1)
    print("Attempting to build back end with dbt...")
    run_dbt_command("dbt build", "Seeding, Building, and Testing dbt models")
    run_dbt_command("dbt docs generate", "Generating dbt documentation artifacts")
    print("\nBuild Complete")


if __name__ == "__main__":
    main()
