import os
import subprocess
import venv
import sys
import time

VENV_DIR = ".venv"

ENV_DEFAULTS = {
    "POSTGRES_USER": "thomas",
    "POSTGRES_PASSWORD": "mind_the_gap",
    "POSTGRES_DB": "subway_system",
    "DB_SCHEMA": "public_transit",
    "POSTGRES_PORT": "5432",
    "HOST_NAME": "localhost",
    "KAFKA_BROKER_PORT": "9092",
    "DB_CONNECTION": "postgresql://thomas:mind_the_gap@localhost:5432/subway_system",
}


def create_env_file():
    if not os.path.exists(".env"):
        with open(".env", "w") as f:
            f.write("# Auto-generated by build.py for local docker setup\n")
            for key, value in ENV_DEFAULTS.items():
                f.write(f"{key}={value}\n")
        print(".env file created.")
    else:
        print(".env file already exists.")


def create_venv():
    if not os.path.exists(VENV_DIR):
        print(f"Creating virtual environment at {VENV_DIR}...")
        venv.create(VENV_DIR, with_pip=True)
        print("Done.")


def get_clean_exception_message(generic_exception: Exception) -> str:
    return (
        generic_exception.stderr.strip()
        if generic_exception.stderr
        else "No error message captured"
    )


def run_command(command, description, continue_if_failed=False):
    try:
        subprocess.check_call(command, shell=True)
        print(f" {description} Complete!\n")
    except subprocess.CalledProcessError as e:
        message = get_clean_exception_message(e)
        if continue_if_failed:
            print(f"Command {description} failed with: {message}")
            print("Non critical, or expected error, continuing")
        else:
            print(f"Error during: {description}:\n {message}")
            sys.exit(1)


def is_running_outside_virtual_environment() -> bool:
    return sys.prefix == sys.base_prefix


def check_env():
    if is_running_outside_virtual_environment():
        print("Script is running outside venv.")
        create_venv()
        if sys.platform == "win32":
            venv_python = os.path.join(VENV_DIR, "Scripts", "python.exe")
        else:
            venv_python = os.path.join(VENV_DIR, "bin", "python")
        try:
            subprocess.check_call([venv_python] + sys.argv)
        except subprocess.CalledProcessError as e:
            sys.exit(e.returncode)
        # Exit the parent process once the child finishes
        sys.exit(0)


def run_dbt_command(command, desc):
    print(f"Running {desc}...")
    original_dir = os.getcwd()

    dbt_dir = "dbt"
    if os.path.exists("dbt_project.yml"):
        dbt_dir = "."
    try:
        os.chdir(dbt_dir)

        custom_env = os.environ.copy()
        #custom_env["PYTHONWARNINGS"] = "ignore"

        # Inject the venv's bin/Scripts folder into the PATH
        venv_bin = os.path.dirname(sys.executable)
        custom_env["PATH"] = f"{venv_bin}{os.pathsep}{custom_env.get('PATH', '')}"

        subprocess.check_call(command, shell=True, env=custom_env)
        print(f"{desc} Complete!\n")

    except subprocess.CalledProcessError as e:
        exception_message = get_clean_exception_message(e)
        print(f"Error during command {desc}, failed with {exception_message}")
        sys.exit(1)
    finally:
        os.chdir(original_dir)


def eradicate_zombies():
    try:
        subprocess.run(["pkill", "-f", "consumer.py"], stderr=subprocess.DEVNULL)
        subprocess.run(["pkill", "-f", "run.py"], stderr=subprocess.DEVNULL)
        print("Process table sanitized.")
    except Exception as e:
        print(f"Zombie sweep failed: {e}")


def print_activation_instructions():
    print("BUILD COMPLETE: System is ready to run")
    print("\nTo start the simulation, you must first activate the virtual environment.")

    if sys.platform == "win32":
        print("Copy and paste this command into your terminal:")
        print("  .venv\\Scripts\\activate")
    else:
        print("Copy and paste this command into your terminal:")
        print("  source .venv/bin/activate")

    print("\nThen run:")
    print("  python run.py\n")


def main():
    print("Starting build...\n")
    create_env_file()
    check_env()
    eradicate_zombies()
    run_command(
        f"{sys.executable} -m pip install -r requirements.txt",
        "Installing Python dependencies",
    )
    run_command(f"{sys.executable} -m pytest src/", "Running data generator tests")
    run_command(
        "docker compose down -v",
        "Shutting off containers, if present...",
        continue_if_failed=True,
    )
    run_command(
        "docker compose up -d --force-recreate", "Starting Docker Infrastructure"
    )
    print("Waiting 3s before attempting database initialization...")
    for i in range(3, 0, -1):
        print(i)
        time.sleep(1)

    run_dbt_command("dbt build", "Seeding, Building, and Testing dbt models")
    run_dbt_command("dbt docs generate", "Generating dbt documentation artifacts")

    print_activation_instructions()


if __name__ == "__main__":
    main()
